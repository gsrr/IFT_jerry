
<h1 class="sectionedit1" id="faq">FAQ</h1>
<div class="level1">
<pre class="file">Q1 : file path在一般的mount point 下與在fuse的mount point下有什麼不一樣?
Ans:
路徑會不一樣, 我們可以分成
xfs_path : /Pool-1/Volume1/.share/files/file1
fuse_path : /Pool-1/Volume1/share/file1

Q2 : rsync在備份檔案前會先比對兩邊的hash content , 若不一樣的話, 在備份檔案時會有什麼不一樣?
Ans:
1. 若比對檔案的結果為相同時, rsync就不會將source的檔案備份過去.
2. 若比較檔案的結果為不同時, rsync會將source的檔案整個在備份過去一次.

Q3 : 現在整個流程大概如何? (read / write)
Ans:
流程上應該是: (因為在cache mode時, file有可能存在, 有可能不存在.)
read : 詢問fuse上的file是否存在 --&gt; (Download file (不存在)) --&gt; read file
write : 詢問fuse上的file是否存在 --&gt; (Download file (不存在)) --&gt; compare file --&gt; write file

Q4 : Performance
Ans:
[root@nas_8716691_a Volume_1]# rsync -a --progress normal/ admin@127.0.0.1::aaa
Password:
sending incremental file list
./
file10G_1
 10485760000 100%  125.73MB/s    0:01:19 (xfer#1, to-check=0/2)

sent 10487040096 bytes  received 30 bytes  127115637.89 bytes/sec
total size is 10485760000  speedup is 1.00
[root@nas_8716691_a Volume_1]# rsync -a --progress normal/ admin@127.0.0.1::bbb
Password:
sending incremental file list
./
file10G_1
 10485760000 100%  180.36MB/s    0:00:55 (xfer#1, to-check=0/2)

sent 10487040096 bytes  received 30 bytes  179265643.18 bytes/sec
total size is 10485760000  speedup is 1.00

Q5 : what is sum_struct?
Ans:
</pre>

</div>
<!-- EDIT1 SECTION "FAQ" [1-1572] -->
<h1 class="sectionedit2" id="flow_of_source_code">flow of source code</h1>
<div class="level1">
<pre class="file"># rsync client (for read)
# rsync server-ssh (for write)
# rsync daemon (for writie)


[# rsync daemon (for writie)]
file : io.c
rsync_module --&gt; chroot(module_chdir) 
module_dir : /Pool-1/Volume_1/aliyun_rsync/aaa

recv_files --&gt; receive_data(fname) -&gt; write_file
recv_files --&gt; read_ndx_and_attrs --&gt; writefd_unbuffered --&gt; write (cnt = write(fd, buf + total, n);)

ndx : index of file list
在recv_files裡面有 fd2 = open_tmpfile(fnametmp, fname, file);
(fd1為read fd, fd2為write fd)

其中 n = len - total
totoal 為write總量.

finish_transfer function : transfer完成後, 進行rename動作

[# rsync server-ssh (for write)]
do_server_recv --&gt; get_local_name --&gt; change_dir (dir=dir@entry=0x5555557d4680 &quot;/root/test&quot;, set_path_only=set_path_only@entry=0)

receive_data(fname) --&gt; 從fnametmp rename到 fname

# rsync client (for read)
start_client --&gt; client_run --&gt; send_files --&gt; match_sums --&gt; matched --&gt; send_token --&gt; 
simple_send_token --&gt; map_ptr (slide the read window in the file)

-----------------------------------------------
在send_files裡會open file name --&gt; fd = do_open(fname, O_RDONLY, 0);
-----------------------------------------------
struct map_struct {
	OFF_T file_size;	/* File size (from stat)		*/
	OFF_T p_offset;		/* Window start				*/
	OFF_T p_fd_offset;	/* offset of cursor in fd ala lseek	*/
	char *p;		/* Window pointer			*/
	int32 p_size;		/* Largest window size we allocated	*/
	int32 p_len;		/* Latest (rounded) window size		*/
	int32 def_window_size;	/* Default window size			*/
	int fd;			/* File Descriptor			*/
	int status;		/* first errno from read errors		*/
};
-----------------------------------------------
readfd_unbuffered --&gt; read_timeout --&gt; read</pre>

</div>
<!-- EDIT2 SECTION "flow of source code" [1573-] -->